
Stop and remove previous Docker containers...

Generate Dockerfile from ./partiel-solution...

Build Dockerfile...

Run Dockerfile...

Run test suite against container...

    Lecture du code source fourni
    ℹ 'use strict';

      const { PORT, MONGODB_URL, MONGODB_DATABASE, MONGODB_COLLECTION } = process.env;

      console.log('Env vars:', {
        PORT,
        MONGODB_URL,
        MONGODB_DATABASE,
        MONGODB_COLLECTION
      });

      const express = require('express');
      const app = express();

      const MongoClient = require('mongodb').MongoClient;

      async function getLastVistor() {
        const client = new MongoClient(MONGODB_URL);
        await client.connect();
        const db = client.db(MONGODB_DATABASE);
        const col = db.collection(MONGODB_COLLECTION);
        const doc = await col.findOne();
        client.close();
        return doc;
      }

      async function storeVisitor(nom) {
        const client = new MongoClient(MONGODB_URL);
        await client.connect();
        const db = client.db(MONGODB_DATABASE);
        const col = db.collection(MONGODB_COLLECTION);
        await col.deleteMany({});
        await col.insertOne({ nom });
        client.close();
      }

      app.use(express.urlencoded()); // pour décoder les données URL-encodées des requêtes

      app.post('/', async (req, res) => {
        const { nom } = req.body;
        if (nom) await storeVisitor(nom);
        res.send(nom ? `Bienvenue, ${nom}.` : 'Il manque votre nom.');
      });

      app.get('/', async (req, res) => {
        try {
          const { nom } = (await getLastVistor()) || {};
          res.send(
            nom
              ? `La dernière personne que j'ai rencontrée est: ${nom}.`
              : `Je n'ai rencontré personne pour l'instant`
          );
        } catch (err) {
          console.error(err);
          res.send(`J'ai perdu la mémoire...`);
        }
      });

      app.listen(PORT, function() {
        console.log('The server is listening on port', PORT);
      });

  ✔ server.js utilise seulement await pour récupérer les valeurs promises
  ✖ GET / {} -> /Je n'ai rencontré personne pour l'instant/ Rejected promise returned by test
  ✖ POST / {} -> /Il manque votre nom/ Rejected promise returned by test
  ✖ POST / "nom=adrien" -> /Bienvenue, adrien/ Rejected promise returned by test

  3 tests failed

  GET / {} -> /Je n'ai rencontré personne pour l'instant/


  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNRESET',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 0,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: undefined,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: null,
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'socket hang up',
  }



  POST / {} -> /Il manque votre nom/


  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNRESET',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'post',
      timeout: 0,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `POST / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        Content-Type: application/x-www-form-urlencoded␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        Content-Length: 0␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: undefined,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'POST',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: null,
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: true,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'POST',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'socket hang up',
  }



  POST / "nom=adrien" -> /Bienvenue, adrien/


  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNRESET',
    config: {
      adapter: Function httpAdapter {},
      data: 'nom=adrien',
      headers: {
        Accept: 'application/json, text/plain, */*',
        'Content-Length': 10,
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'post',
      timeout: 0,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: null,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `POST / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        Content-Type: application/x-www-form-urlencoded␍␊
        User-Agent: axios/0.19.0␍␊
        Content-Length: 10␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: undefined,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'POST',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: null,
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: true,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'POST',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [
        Object { … },
      ],
      _requestBodyLength: 10,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'socket hang up',
  }


Stop and remove Docker containers...
