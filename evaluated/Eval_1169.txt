
Stop and remove previous Docker containers...

🐳 Generate and run Dockerfile from ./student-code/...

👾 Run test suite against container...

    Lecture du code source fourni
    ℹ const express = require('express');
      const bodyParser = require("body-parser");

      const app = express();

      require('dotenv').config();

      app.use(bodyParser.json());

      const PORT = process.env.PORT || 3000;

      app.listen(PORT, () => {
          console.log(`${PORT}`);
      });

      const MongoClient = require("mongodb").MongoClient;
      const url = process.env.MONGODB_URL;
      async function insertName(nom) {
          const client = new MongoClient(url);

          try {
              await client.connect();

              const db = client.db(process.env.MONGODB_DATABASE);
              const collection = db.collection(process.env.MONGODB_COLLECTION);

              await collection.insertOne({
                  name: nom,
              });

              console.log("Messages inserted");
          } catch (error) {
              console.log(error);
          }

          client.close();
      }

      async function getLastName() {
          const client = new MongoClient(url);

          try {
              await client.connect();

              const db = client.db(process.env.MONGODB_DATABASE);
              const collection = db.collection(process.env.MONGODB_COLLECTION);

              const response = await collection.find().sort({ _id: -1 }).limit(1).toArray();

              return response;
          } catch (error) {
              console.log(error);
              return "error";
          }

          client.close();
      }


      app.post("/", (req, res) => {
          const nom = req.body.nom;
          if (nom != undefined) {
              insertName(nom);
              res.send("Bienvenue, " + nom + ".");
          } else {
              res.send("Il manque votre nom.");
          }
      });

      app.get("/", async (req, res) => {
          const nom = await getLastName();
          if (nom[0]["name"] != undefined) {
              res.send("La dernière personne que j'ai rencontrée est: " + nom[0]["name"] + ".");
          }
          else if (nom === "error") {
              res.send("J'ai perdu la mémoire...");
          }
          else {
              res.send("Je n'ai rencontré personne pour l'instant");
          }
      });


  ✔ server.js utilise seulement await pour récupérer les valeurs promises
  ✔ server.js contient l'intégralité du code source de votre programme
  ✔ package.json permet d'installer les dépendances nécessaires à l'aide de npm install
  ✖ package.json permet de démarrer le serveur à l'aide de npm start `t.regex()` must be called with a string
  ✖ README.md inclue les instructions à suivre pour installer, exécuter et tester le serveur 
(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)

(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)
(node) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.

(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)
(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 2)

(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)

(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 3)

  ✖ le serveur répond sur le port 3000 Rejected promise returned by test
(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)
(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 4)

  ✖ (1) GET / {} -> /Je n'ai rencontré personne pour l'instant/ Rejected promise returned by test
  ✔ (2) POST / {} -> /Il manque votre nom/
(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)
(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 5)

  ✖ (3) GET / {} -> /Je n'ai rencontré personne pour l'instant/ Rejected promise returned by test
  ✖ (4) POST / "nom=adrien" -> /Bienvenue, adrien/ 
(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)
(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 6)

  ✖ (5) GET / {} -> /La dernière personne que j'ai rencontrée est: adrien/ Rejected promise returned by test
  ✖ (6) POST / "nom=michelle" -> /Bienvenue, michelle/ 
(node) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'name' of undefined
    at app.get (/usr/src/app/server.js:72:15)
    at process._tickCallback (internal/process/next_tick.js:68:7)
(node) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 7)

  ✖ (7) GET / {} -> /La dernière personne que j'ai rencontrée est: michelle/ Rejected promise returned by test
  ✖ MONGODB_COLLECTION ne doit contenir qu'un document avec le nom du dernier visiteur 
{ MongoNetworkError: failed to connect to server [localhost:27027] on first connect [MongoNetworkError: connect ECONNREFUSED 127.0.0.1:27027]
    at Pool.<anonymous> (/usr/src/app/node_modules/mongodb/lib/core/topologies/server.js:438:11)
    at Pool.emit (events.js:198:13)
    at createConnection (/usr/src/app/node_modules/mongodb/lib/core/connection/pool.js:562:14)
    at connect (/usr/src/app/node_modules/mongodb/lib/core/connection/pool.js:995:11)
    at makeConnection (/usr/src/app/node_modules/mongodb/lib/core/connection/connect.js:31:7)
    at callback (/usr/src/app/node_modules/mongodb/lib/core/connection/connect.js:264:5)
    at Socket.err (/usr/src/app/node_modules/mongodb/lib/core/connection/connect.js:294:7)
    at Object.onceWrapper (events.js:286:20)
    at Socket.emit (events.js:198:13)
    at emitErrorNT (internal/streams/destroy.js:91:8) name: 'MongoNetworkError' }

  ✖ (8) GET / -> "J'ai perdu la mémoire...", si la db ne fonctionne plus 

  11 tests failed

  package.json permet de démarrer le serveur à l'aide de npm start

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:92

   91:     const { scripts } = JSON.parse(await runInDocker('cat package.json')…
   92:     t.regex(scripts.start, /node server.js/);                            
   93:   }                                                                      

  `t.regex()` must be called with a string

  Called with:

  undefined



  README.md inclue les instructions à suivre pour installer, exécuter et tester le serveur

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:101

   100:     t.regex(readme, /npm i/);                
   101:     t.regex(readme, /node server|npm start/);
   102:     t.regex(readme, /npm test|curl/);        

  Value must match expression:

  `# Partiel NodeJS 1169␊
  ␊
  ## Installation␊
  ␊
  ```␊
  $ npm install␊
  ```␊
  ␊
  ### 1 - POST␊
  ␊
  ```␊
  $ curl -X POST --header "Content-Type: application/json" --data "{\\"nom\\":\\"Mathieu\\"}" http://localhost:3000/␊
  ```␊
  renverra "Bienvenue, Mathieu."␊
  ␊
  ```␊
  $ curl -X POST --header "Content-Type: application/json" --data "{\\"nom\\":\\"\\"}" http://localhost:3000/␊
  ```␊
  ␊
  renverra "Il manque votre nom."␊
  ␊
  ### 2 - GET␊
  ␊
  ```␊
  http://localhost:3000/␊
  ```␊
  renverra "La dernière personne que j'ai rencontrée est: Mathieu." si la dernière personne à avoir été ajouté à la BDD est Mathieu.␊
  ␊
  renverra "La dernière personne que j'ai rencontrée est: Mathieu." si la BDD est vide.␊
  ␊
  renverra "La dernière personne que j'ai rencontrée est: Mathieu." si il y a une erreur.␊
  `

  Regular expression:

  /node server|npm start/



  le serveur répond sur le port 3000


  Rejected promise returned by test. Reason:

  Error {
    cmd: 'PORT=3000 ./wait-for-student-server.sh',
    code: 1,
    killed: false,
    signal: null,
    stderr: '',
    stdout: `␊
    Wait for server on port 3000...␊
    (1)␊
    (2)␊
    (3)␊
    ❌  Server is NOT listening on port 3000.␊
    `,
    message: `Command failed: PORT=3000 ./wait-for-student-server.sh␊
    `,
  }



  (1) GET / {} -> /Je n'ai rencontré personne pour l'instant/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595009352414,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { … },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (3) GET / {} -> /Je n'ai rencontré personne pour l'instant/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595009353950,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { … },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (4) POST / "nom=adrien" -> /Bienvenue, adrien/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:155

   154:       const { data } = await axios[method.toLowerCase()](url, body);
   155:       t.regex(data, exp);                                           
   156:     }                                                               

  Value must match expression:

  'Il manque votre nom.'

  Regular expression:

  /Bienvenue, adrien/



  (5) GET / {} -> /La dernière personne que j'ai rencontrée est: adrien/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595009355476,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { … },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (6) POST / "nom=michelle" -> /Bienvenue, michelle/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:155

   154:       const { data } = await axios[method.toLowerCase()](url, body);
   155:       t.regex(data, exp);                                           
   156:     }                                                               

  Value must match expression:

  'Il manque votre nom.'

  Regular expression:

  /Bienvenue, michelle/



  (7) GET / {} -> /La dernière personne que j'ai rencontrée est: michelle/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { … },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1␍␊
        Accept: application/json, text/plain, */*␍␊
        User-Agent: axios/0.19.0␍␊
        Host: localhost:3000␍␊
        Connection: close␍␊
        ␍␊
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595009357000,
        agent: Agent { … },
        chunkedEncoding: false,
        connection: Socket { … },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { … },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { … },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { … },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { … },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { … },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { … },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  MONGODB_COLLECTION ne doit contenir qu'un document avec le nom du dernier visiteur

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:176

   175:     );                                                       
   176:     t.is(docs.length, 1);                                    
   177:     t.deepEqual(Object.keys(docs[0]).sort(), ['_id', 'nom']);

  Difference:

  - 0
  + 1



  (8) GET / -> "J'ai perdu la mémoire...", si la db ne fonctionne plus

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:187

   186:     const { data } = await axios.get(`http://localhost:${envVars.PORT}/…
   187:     t.regex(data, /J'ai perdu la mémoire/);                            
   188:   }                                                                     

  Value must match expression:

  'J\'ai perdu la mémoire...'

  Regular expression:

  /J'ai perdu la mémoire/


🧹 Stop and remove Docker containers...
