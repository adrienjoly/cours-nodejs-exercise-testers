
Stop and remove previous Docker containers...

üê≥ Generate and run Dockerfile from ./student-code/...

üëæ Run test suite against container...

    Lecture du code source fourni
    ‚Ñπ // import des d√©pendance
      const express = require('express');
      const bodyParser = require('body-parser');
      const mongoose  = require('mongoose');
      const { MongoClient } = require('mongodb');
      const options = { server: { socketOptions: { keepAlive: 300000, connectTimeoutMS: 30000 } }, 
          replset: { socketOptions: { keepAlive: 300000, connectTimeoutMS : 30000 } } };

      // config constante
      const port = process.env.port || 3000,
          MONGODB_COLLECTION = process.env.MONGODB_COLLECTION || 'user',
          MONGODB_DATABASE = process.env.MONGODB_DATABASE || 'apiNom',
          MONGODB_URL = process.env.MONGODB_URL || 'mongodb://localhost:27017/apiNom';

      // init mongodb
      const client = new MongoClient(MONGODB_URL);
      mongoose.connect(MONGODB_URL, options);

      // create du schema user
      const userSchema = mongoose.Schema({
          nom: String
      })
      const User = mongoose.model('User', userSchema)

      // config express
      const app = express();

      app.use(bodyParser.urlencoded({extended: true}))

      app.get('/', async (req, res) => {
          try {
              const lastUser = await User.findOne().sort({ field: 'asc', _id: -1 }).limit(1)
              if (lastUser) {
                  res.send("La derni√®re personne que j'ai rencontr√©e est: " + lastUser.nom + ".");
              } else {
                  res.send("Je n'ai rencontr√© personne pour l'instant")
              }
          } catch (err) {
              res.send("J'ai perdu la m√©moire...");
          }
      })

      app.post('/', (req, res) => {
          console.log(MONGODB_URL)
          if (req.body.nom) {
              const user = new User();
              user.nom = req.body.nom;
              user.save();
              res.send("Bienvenue, " + user.nom + '.');
          } else {
              res.send('Il manque votre nom.')
          }
      })

      // lance le serv
      app.listen(port, () => {
          console.log('app listen on http://localhost:' + port)
      })
  ‚úî server.js utilise seulement await pour r√©cup√©rer les valeurs promises
  ‚úî server.js contient l'inteÃÅgraliteÃÅ du code source de votre programme
  ‚úñ package.json permet d'installer les deÃÅpendances neÃÅcessaires aÃÄ l'aide de npm install 
  ‚úî package.json permet de deÃÅmarrer le serveur aÃÄ l'aide de npm start
  ‚úî README.md inclue les instructions aÃÄ suivre pour installer, exeÃÅcuter et tester le serveur
[MONGODB SERVER] [31m[2020-07-18 06:42:37.885] [ERROR] mongodb-fs.processor - [39mUncaught exception processing socket data:  TypeError: Cannot read property 'users' of undefined
[MONGODB SERVER] [31m[2020-07-18 06:42:39.889] [ERROR] mongodb-fs.processor - [39mUncaught exception processing socket data:  TypeError: Cannot read property 'users' of undefined
[MONGODB SERVER] [31m[2020-07-18 06:42:41.912] [ERROR] mongodb-fs.processor - [39mUncaught exception processing socket data:  TypeError: Cannot read property 'users' of undefined
  ‚úñ le serveur r√©pond sur le port 3000 Rejected promise returned by test
[MONGODB SERVER] [31m[2020-07-18 06:42:42.948] [ERROR] mongodb-fs.processor - [39mUncaught exception processing socket data:  TypeError: Cannot read property 'users' of undefined
  ‚úñ (1) GET / {} -> /Je n'ai rencontreÃÅ personne pour l'instant/ Rejected promise returned by test
  ‚úî (2) POST / {} -> /Il manque votre nom/
[MONGODB SERVER] [31m[2020-07-18 06:42:44.493] [ERROR] mongodb-fs.processor - [39mUncaught exception processing socket data:  TypeError: Cannot read property 'users' of undefined
  ‚úñ (3) GET / {} -> /Je n'ai rencontreÃÅ personne pour l'instant/ Rejected promise returned by test
  ‚úî (4) POST / "nom=adrien" -> /Bienvenue, adrien/
  ‚úñ (5) GET / {} -> /La dernieÃÄre personne que j'ai rencontreÃÅe est: adrien/ Rejected promise returned by test
  ‚úî (6) POST / "nom=michelle" -> /Bienvenue, michelle/
  ‚úñ (7) GET / {} -> /La dernieÃÄre personne que j'ai rencontreÃÅe est: michelle/ Rejected promise returned by test
  ‚úñ MONGODB_COLLECTION ne doit contenir qu'un document avec le nom du dernier visiteur 
  ‚úñ (8) GET / -> "J'ai perdu la meÃÅmoire...", si la db ne fonctionne plus Rejected promise returned by test

  8 tests failed

  package.json permet d'installer les deÃÅpendances neÃÅcessaires aÃÄ l'aide de npm install

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:86

   85:     t.true(deps.includes('express'));
   86:     t.true(deps.includes('mongodb'));
   87:   }                                  

  Value is not `true`:

  false



  le serveur r√©pond sur le port 3000


  Rejected promise returned by test. Reason:

  Error {
    cmd: 'PORT=3000 ./wait-for-student-server.sh',
    code: 1,
    killed: false,
    signal: null,
    stderr: '',
    stdout: `‚êä
    Wait for server on port 3000...‚êä
    (1)‚êä
    (2)‚êä
    (3)‚êä
    ‚ùå  Server is NOT listening on port 3000.‚êä
    `,
    message: `Command failed: PORT=3000 ./wait-for-student-server.sh‚êä
    `,
  }



  (1) GET / {} -> /Je n'ai rencontreÃÅ personne pour l'instant/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { ‚Ä¶ },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1‚êç‚êä
        Accept: application/json, text/plain, */*‚êç‚êä
        User-Agent: axios/0.19.0‚êç‚êä
        Host: localhost:3000‚êç‚êä
        Connection: close‚êç‚êä
        ‚êç‚êä
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595054564416,
        agent: Agent { ‚Ä¶ },
        chunkedEncoding: false,
        connection: Socket { ‚Ä¶ },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { ‚Ä¶ },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { ‚Ä¶ },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { ‚Ä¶ },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { ‚Ä¶ },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { ‚Ä¶ },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { ‚Ä¶ },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (3) GET / {} -> /Je n'ai rencontreÃÅ personne pour l'instant/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { ‚Ä¶ },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1‚êç‚êä
        Accept: application/json, text/plain, */*‚êç‚êä
        User-Agent: axios/0.19.0‚êç‚êä
        Host: localhost:3000‚êç‚êä
        Connection: close‚êç‚êä
        ‚êç‚êä
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595054565965,
        agent: Agent { ‚Ä¶ },
        chunkedEncoding: false,
        connection: Socket { ‚Ä¶ },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { ‚Ä¶ },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { ‚Ä¶ },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { ‚Ä¶ },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { ‚Ä¶ },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { ‚Ä¶ },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { ‚Ä¶ },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (5) GET / {} -> /La dernieÃÄre personne que j'ai rencontreÃÅe est: adrien/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { ‚Ä¶ },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1‚êç‚êä
        Accept: application/json, text/plain, */*‚êç‚êä
        User-Agent: axios/0.19.0‚êç‚êä
        Host: localhost:3000‚êç‚êä
        Connection: close‚êç‚êä
        ‚êç‚êä
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595054567497,
        agent: Agent { ‚Ä¶ },
        chunkedEncoding: false,
        connection: Socket { ‚Ä¶ },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { ‚Ä¶ },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { ‚Ä¶ },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { ‚Ä¶ },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { ‚Ä¶ },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { ‚Ä¶ },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { ‚Ä¶ },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  (7) GET / {} -> /La dernieÃÄre personne que j'ai rencontreÃÅe est: michelle/

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { ‚Ä¶ },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1‚êç‚êä
        Accept: application/json, text/plain, */*‚êç‚êä
        User-Agent: axios/0.19.0‚êç‚êä
        Host: localhost:3000‚êç‚êä
        Connection: close‚êç‚êä
        ‚êç‚êä
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595054569026,
        agent: Agent { ‚Ä¶ },
        chunkedEncoding: false,
        connection: Socket { ‚Ä¶ },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { ‚Ä¶ },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { ‚Ä¶ },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { ‚Ä¶ },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { ‚Ä¶ },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { ‚Ä¶ },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { ‚Ä¶ },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)



  MONGODB_COLLECTION ne doit contenir qu'un document avec le nom du dernier visiteur

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/test-partiel.js:178

   177:     );                                                       
   178:     t.is(docs.length, 1);                                    
   179:     t.deepEqual(Object.keys(docs[0]).sort(), ['_id', 'nom']);

  Difference:

  - 0
  + 1



  (8) GET / -> "J'ai perdu la meÃÅmoire...", si la db ne fonctionne plus

  /Users/adrienjoly/dev/adrienjoly/cours-nodejs-exercise-testers/node_modules/axios/lib/core/createError.js:16

  Rejected promise returned by test. Reason:

  Error {
    code: 'ECONNABORTED',
    config: {
      adapter: Function httpAdapter {},
      data: undefined,
      headers: {
        Accept: 'application/json, text/plain, */*',
        'User-Agent': 'axios/0.19.0',
      },
      maxContentLength: -1,
      method: 'get',
      timeout: 1500,
      transformRequest: [
        Function transformRequest {},
      ],
      transformResponse: [
        Function transformResponse {},
      ],
      url: 'http://localhost:3000/',
      validateStatus: Function validateStatus {},
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    },
    isAxiosError: true,
    request: Writable {
      _currentRequest: ClientRequest {
        _contentLength: 0,
        _ended: false,
        _events: Object { ‚Ä¶ },
        _eventsCount: 6,
        _hasBody: true,
        _header: `GET / HTTP/1.1‚êç‚êä
        Accept: application/json, text/plain, */*‚êç‚êä
        User-Agent: axios/0.19.0‚êç‚êä
        Host: localhost:3000‚êç‚êä
        Connection: close‚êç‚êä
        ‚êç‚êä
        `,
        _headerSent: true,
        _last: true,
        _maxListeners: undefined,
        _onPendingData: Function noopPendingOutput {},
        _redirectable: [Circular],
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _trailer: '',
        aborted: 1595054573523,
        agent: Agent { ‚Ä¶ },
        chunkedEncoding: false,
        connection: Socket { ‚Ä¶ },
        finished: true,
        maxHeadersCount: null,
        method: 'GET',
        output: [],
        outputCallbacks: [],
        outputEncodings: [],
        outputSize: 0,
        parser: HTTPParser { ‚Ä¶ },
        path: '/',
        res: null,
        sendDate: false,
        shouldKeepAlive: false,
        socket: Socket { ‚Ä¶ },
        socketPath: undefined,
        timeout: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        useChunkedEncodingByDefault: false,
        writable: true,
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: Object { ‚Ä¶ },
      },
      _currentUrl: 'http://localhost:3000/',
      _events: {
        error: Function handleRequestError {},
        response: Function handleResponse {},
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _onNativeResponse: Function {},
      _options: {
        agent: undefined,
        auth: undefined,
        headers: Object { ‚Ä¶ },
        hostname: 'localhost',
        maxBodyLength: 10485760,
        maxRedirects: 21,
        method: 'GET',
        nativeProtocols: Object { ‚Ä¶ },
        path: '/',
        pathname: '/',
        port: '3000',
        protocol: 'http:',
      },
      _redirectCount: 0,
      _redirects: [],
      _requestBodyBuffers: [],
      _requestBodyLength: 0,
      _writableState: WritableState [
        autoDestroy: false,
        bufferProcessing: false,
        bufferedRequest: null,
        bufferedRequestCount: 0,
        corked: 0,
        corkedRequestsFree: Object { ‚Ä¶ },
        decodeStrings: true,
        defaultEncoding: 'utf8',
        destroyed: false,
        emitClose: true,
        ended: false,
        ending: false,
        errorEmitted: false,
        finalCalled: false,
        finished: false,
        highWaterMark: 16384,
        lastBufferedRequest: null,
        length: 0,
        needDrain: false,
        objectMode: false,
        onwrite: Function bound onwrite {},
        pendingcb: 0,
        prefinished: false,
        sync: true,
        writecb: null,
        writelen: 0,
        writing: false,
      ],
      writable: true,
    },
    response: undefined,
    toJSON: Function {},
    message: 'timeout of exceeded',
  }

  createError (node_modules/axios/lib/core/createError.js:16:15)
  Timeout.handleRequestTimeout (node_modules/axios/lib/adapters/http.js:252:16)


üßπ Stop and remove Docker containers...
